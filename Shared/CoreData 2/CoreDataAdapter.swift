//
//  CoreDataAdapter.swift
//  Fitter V2
//
//  üìã IMPLEMENTA√á√ÉO DA SERIALIZA√á√ÉO/DESERIALIZA√á√ÉO sensorData JSON
//  
//  üéØ OBJETIVO: Otimizar modelo Core Data para hist√≥rico
//  ‚Ä¢ ANTES: 18 atributos individuais de sensores em m√∫ltiplas entidades
//  ‚Ä¢ DEPOIS: 1 campo JSON consolidado APENAS em CDHistorySet/CDWorkoutHistory
//  ‚Ä¢ TEMPO REAL: heartRate, caloriesBurned, timers via HealthKitManager/TimerService
//  
//  üîÑ FLUXO DE DADOS:
//  1. Apple Watch ‚Üí [String: Any] (dados individuais)
//  2. CoreDataAdapter ‚Üí SensorData struct (consolida√ß√£o)
//  3. SensorData ‚Üí JSON Data (serializa√ß√£o)
//  4. JSON Data ‚Üí Binary Data Core Data (External Storage)
//  
//  ‚ö° BENEF√çCIOS:
//  ‚Ä¢ Performance: External Storage para dados grandes
//  ‚Ä¢ Escalabilidade: Novos sensores n√£o alteram schema
//  ‚Ä¢ Manutenibilidade: C√≥digo menos duplicado
//  ‚Ä¢ Flexibilidade: JSON permite estruturas vari√°veis
//
//  Created by Daniel Lobo on 13/05/25.
//

import Foundation
import CoreData

/// Adaptador otimizado para serializa√ß√£o/deserializa√ß√£o de dados do Core Data
/// üéØ Focado na nova estrutura sensorData JSON consolidada
/// 
/// **ARQUITETURA OTIMIZADA:**
/// - Substitui 18 atributos individuais de sensores por 2 campos JSON consolidados
/// - Utiliza Binary Data com External Storage para performance
/// - Mant√©m heartRate e caloriesBurned separados para facilidade de consulta
/// - Suporte completo a dados do Apple Watch (aceler√¥metro, girosc√≥pio, gravidade, atitude, magn√©tico)
final class CoreDataAdapter {
    
    // MARK: - JSON Serialization/Deserialization
    // üìã Esta se√ß√£o implementa a convers√£o entre SensorData struct e Binary Data JSON
    
    /// üéØ Encoder JSON otimizado para SensorData
    /// - Converte struct SensorData ‚Üí JSON Data para armazenamento no Core Data
    /// - Usa ISO8601 para timestamps precisos
    /// - Campos ordenados (.sortedKeys) para consist√™ncia entre serializations
    private static let sensorEncoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .iso8601
        encoder.outputFormatting = .sortedKeys // Para consist√™ncia e debug
        return encoder
    }()
    
    /// üéØ Decoder JSON otimizado para SensorData
    /// - Converte JSON Data ‚Üí struct SensorData para uso na aplica√ß√£o
    /// - Compat√≠vel com timestamps ISO8601
    /// - Trata automaticamente valores opcionais (sensores podem ser nil)
    private static let sensorDecoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
        return decoder
    }()
    
    // MARK: - SensorData Conversion
    // üîÑ M√©todos principais para convers√£o entre SensorData struct ‚Üî Binary Data JSON
    
    /// üì§ Serializa SensorData para Binary Data (Core Data)
    /// 
    /// **Processo:**
    /// 1. Recebe struct SensorData com dados de sensores do Apple Watch
    /// 2. Converte para JSON usando encoder otimizado
    /// 3. Retorna Data para armazenar no campo `sensorData` (Binary Data + External Storage)
    /// 
    /// **Uso:** `cdCurrentSet.sensorData = CoreDataAdapter.serializeSensorData(sensors)`
    ///
    /// - Parameter sensorData: Struct com dados consolidados de aceler√¥metro, girosc√≥pio, etc.
    /// - Returns: Binary Data para salvar no Core Data, ou nil se houver erro
    static func serializeSensorData(_ sensorData: SensorData) -> Data? {
        do {
            return try sensorEncoder.encode(sensorData)
        } catch {
            print("‚ùå Erro ao serializar SensorData: \(error)")
            return nil
        }
    }
    
    /// üì• Deserializa Binary Data para SensorData (Core Data ‚Üí App)
    /// 
    /// **Processo:**
    /// 1. Recebe Binary Data do campo `sensorData` do Core Data
    /// 2. Converte JSON para struct SensorData usando decoder otimizado
    /// 3. Retorna struct pronto para uso na aplica√ß√£o
    /// 
    /// **Uso:** `let sensors = CoreDataAdapter.deserializeSensorData(from: cdSet.sensorData)`
    ///
    /// - Parameter data: Binary Data JSON vindo do Core Data
    /// - Returns: Struct SensorData com dados dos sensores, ou nil se inv√°lido
    static func deserializeSensorData(from data: Data) -> SensorData? {
        do {
            return try sensorDecoder.decode(SensorData.self, from: data)
        } catch {
            print("‚ùå Erro ao deserializar SensorData: \(error)")
            return nil
        }
    }
    
    // MARK: - Watch Data Integration (Modernizado)
    // üì± Integra√ß√£o com Apple Watch usando nova estrutura JSON consolidada
    
    /// üéØ Cria CDHistorySet a partir de dados recebidos do Watch (usando sensorData JSON)
    /// 
    /// **NOVA ARQUITETURA:**
    /// - Recebe dados individuais do Watch (accelerationX, rotationY, etc.)
    /// - Consolida em struct SensorData unificada
    /// - Serializa para JSON e armazena em Binary Data
    /// - Mant√©m heartRate/caloriesBurned como campos separados para queries r√°pidas
    /// 
    /// **Redu√ß√£o de complexidade:** 18 atributos ‚Üí 2 campos JSON + 2 campos diretos
    ///
    /// - Parameters:
    ///   - data: Dictionary com dados de sensores individuais do Watch
    ///   - sensorId: UUID √∫nico para identifica√ß√£o
    ///   - timestamp: Data/hora da captura
    ///   - context: NSManagedObjectContext para cria√ß√£o da entidade
    /// - Returns: CDHistorySet criado com dados consolidados, ou nil se erro
    static func createHistorySetFromWatch(
        data: [String: Any],
        sensorId: UUID,
        timestamp: Date,
        context: NSManagedObjectContext
    ) -> CDHistorySet? {
        let cdHistorySet = CDHistorySet(context: context)
        
        cdHistorySet.id = sensorId
        cdHistorySet.timestamp = timestamp
        cdHistorySet.order = 0 // Valor padr√£o
        
        // Dados b√°sicos da s√©rie
        if let reps = data["reps"] as? Int {
            cdHistorySet.targetReps = Int32(reps)
        }
        if let weight = data["weight"] as? Double {
            cdHistorySet.weight = weight
        }
        
        // Dados de sa√∫de (mantidos separados para queries r√°pidas)
        // N√ÉO salvamos em heartRateData/caloriesData aqui - apenas campos diretos para queries
        
        // üÜï CONSOLIDA√á√ÉO DE DADOS DE SENSORES EM JSON UNIFICADO (APENAS HIST√ìRICO)
        // SensorData √© usado apenas para an√°lise posterior e hist√≥rico
        // Dados em tempo real (heartRate, caloriesBurned, timers) s√£o processados separadamente
        // via HealthKitManager, TimerService e WatchConnectivity
        do {
            let sensorData = try SensorData(from: data)
            
            // üîÑ SERIALIZA√á√ÉO AUTOM√ÅTICA PARA BINARY DATA (HIST√ìRICO)
            // Converte struct ‚Üí JSON ‚Üí Binary Data e armazena no Core Data
            // Usa External Storage para otimizar performance com dados grandes
            let binaryData = try sensorData.toBinaryData()
            cdHistorySet.setValue(binaryData, forKey: "sensorData")
            
        } catch {
            print("‚ùå Erro ao processar dados do Watch: \(error)")
            return nil
        }
        
        // Cloud sync status
        cdHistorySet.cloudSyncStatus = CloudSyncStatus.pending.rawValue
        
        return cdHistorySet
    }
    
    /// üéØ Cria CDCurrentSet a partir de dados do Watch (SEM sensorData)
    /// 
    /// **DIFEREN√áA DO HistorySet:**
    /// - N√ÉO armazena sensorData (apenas para hist√≥rico)
    /// - Dados em tempo real (heartRate, caloriesBurned, timers) via HealthKitManager/TimerService
    /// - Usado para treinos em andamento (isActive=true)
    ///
    /// - Parameters:
    ///   - data: Dictionary com dados de sensores individuais do Watch
    ///   - sensorId: UUID √∫nico para identifica√ß√£o
    ///   - timestamp: Data/hora da captura
    ///   - context: NSManagedObjectContext para cria√ß√£o da entidade
    /// - Returns: CDCurrentSet criado com dados consolidados, ou nil se erro
    static func createCurrentSetFromWatch(
        data: [String: Any],
        sensorId: UUID,
        timestamp: Date,
        context: NSManagedObjectContext
    ) -> CDCurrentSet? {
        let cdCurrentSet = CDCurrentSet(context: context)
        
        cdCurrentSet.id = sensorId
        cdCurrentSet.timestamp = timestamp
        cdCurrentSet.order = 0 // Valor padr√£o
        cdCurrentSet.isActive = true
        
        // Dados b√°sicos da s√©rie
        if let targetReps = data["targetReps"] as? Int {
            cdCurrentSet.targetReps = Int32(targetReps)
        }
        if let actualReps = data["actualReps"] as? Int {
            cdCurrentSet.actualReps = Int32(actualReps)
        }
        if let weight = data["weight"] as? Double {
            cdCurrentSet.weight = weight
        }
        
        // üÜï DADOS DE SENSORES REMOVIDOS - N√ÉO NECESS√ÅRIOS EM TEMPO REAL
        // Os dados de sensores (SensorData) s√£o apenas para processamento posterior
        // Dados em tempo real s√£o: heartRate, caloriesBurned, timers
        // Processados por: HealthKitManager, TimerService, WatchConnectivity
        
        return cdCurrentSet
    }
    
    // MARK: - Migration Helpers
    
    /// üîÑ Converte dados antigos (atributos individuais) para novo formato JSON
    /// 
    /// **CONTEXTO:**
    /// - M√©todo para migra√ß√£o de dados existentes se necess√°rio
    /// - Como estamos em desenvolvimento inicial, implementa√ß√£o b√°sica suficiente
    /// - Pode ser expandido se dados legados forem encontrados
    /// 
    /// **PROCESSO:**
    /// 1. Verifica se entidade tem atributos legados de sensores (accelerationX, rotationY, etc.)
    /// 2. Se encontrados, consolida em struct SensorData
    /// 3. Serializa para JSON e atualiza campo sensorData
    /// 4. Remove atributos legados (opcional - requer migration mapping)
    ///
    /// - Parameter entity: NSManagedObject (CDCurrentSet ou CDHistorySet) para migrar
    static func migrateLegacySensorData(for entity: NSManagedObject) {
        // Verifica se √© uma entidade v√°lida para migra√ß√£o
        guard entity.entity.name == "CDCurrentSet" || entity.entity.name == "CDHistorySet" else {
            print("‚ö†Ô∏è Entidade \(entity.entity.name ?? "desconhecida") n√£o suporta migra√ß√£o de sensorData")
            return
        }
        
        // Verifica se j√° tem sensorData JSON (n√£o precisa migrar)
        if let _ = entity.value(forKey: "sensorData") as? Data {
            print("‚ÑπÔ∏è Entidade j√° possui sensorData JSON - migra√ß√£o desnecess√°ria")
            return
        }
        
        print("üîÑ Iniciando migra√ß√£o de dados legados para entidade \(entity.entity.name ?? "desconhecida")")
        
        // Coleta atributos legados se existirem
        let legacyAttributes: [String: Any?] = [
            "accelerationX": entity.value(forKey: "accelerationX"),
            "accelerationY": entity.value(forKey: "accelerationY"),
            "accelerationZ": entity.value(forKey: "accelerationZ"),
            "rotationX": entity.value(forKey: "rotationX"),
            "rotationY": entity.value(forKey: "rotationY"),
            "rotationZ": entity.value(forKey: "rotationZ"),
            "gravityX": entity.value(forKey: "gravityX"),
            "gravityY": entity.value(forKey: "gravityY"),
            "gravityZ": entity.value(forKey: "gravityZ"),
            "attitudeRoll": entity.value(forKey: "attitudeRoll"),
            "attitudePitch": entity.value(forKey: "attitudePitch"),
            "attitudeYaw": entity.value(forKey: "attitudeYaw"),
            "magneticFieldX": entity.value(forKey: "magneticFieldX"),
            "magneticFieldY": entity.value(forKey: "magneticFieldY"),
            "magneticFieldZ": entity.value(forKey: "magneticFieldZ")
        ]
        
        // üìç MIGRA√á√ÉO DE DADOS DE LOCALIZA√á√ÉO (se aplic√°vel)
        // Verifica se a entidade suporta dados de localiza√ß√£o
        var locationDataMigrated = false
        if entity.entity.name == "CDCurrentSession" || entity.entity.name == "CDWorkoutHistory" {
            // Coleta dados de localiza√ß√£o legacy se existirem
            let legacyLocationData: [String: Any] = [
                "latitude": entity.value(forKey: "latitude") as? Double ?? 0.0,
                "longitude": entity.value(forKey: "longitude") as? Double ?? 0.0,
                "locationAccuracy": entity.value(forKey: "locationAccuracy") as? Double ?? 0.0
            ].compactMapValues { $0 }
            
            if !legacyLocationData.isEmpty {
                print("üìç Dados de localiza√ß√£o legacy encontrados: \(legacyLocationData.count) campos")
                locationDataMigrated = true
                // Dados de localiza√ß√£o j√° est√£o nos campos corretos, apenas logamos
            }
        }
        
        // Conta quantos atributos legados existem
        let existingLegacyCount = legacyAttributes.compactMap { $0.value }.count
        
        if existingLegacyCount == 0 {
            print("‚ÑπÔ∏è Nenhum atributo legacy encontrado - migra√ß√£o desnecess√°ria")
            return
        }
        
        print("üìä Encontrados \(existingLegacyCount) atributos legados para migra√ß√£o")
        
        // Cria SensorData consolidado com dados legados
        let sensorData = SensorData(
            accelerationX: legacyAttributes["accelerationX"] as? Double,
            accelerationY: legacyAttributes["accelerationY"] as? Double,
            accelerationZ: legacyAttributes["accelerationZ"] as? Double,
            rotationX: legacyAttributes["rotationX"] as? Double,
            rotationY: legacyAttributes["rotationY"] as? Double,
            rotationZ: legacyAttributes["rotationZ"] as? Double,
            gravityX: legacyAttributes["gravityX"] as? Double,
            gravityY: legacyAttributes["gravityY"] as? Double,
            gravityZ: legacyAttributes["gravityZ"] as? Double,
            attitudeRoll: legacyAttributes["attitudeRoll"] as? Double,
            attitudePitch: legacyAttributes["attitudePitch"] as? Double,
            attitudeYaw: legacyAttributes["attitudeYaw"] as? Double,
            magneticFieldX: legacyAttributes["magneticFieldX"] as? Double,
            magneticFieldY: legacyAttributes["magneticFieldY"] as? Double,
            magneticFieldZ: legacyAttributes["magneticFieldZ"] as? Double
        )
        
        // Serializa dados consolidados para JSON
        if let jsonData = serializeSensorData(sensorData) {
            entity.setValue(jsonData, forKey: "sensorData")
            let locationInfo = locationDataMigrated ? " + dados de localiza√ß√£o" : ""
            print("‚úÖ Migra√ß√£o conclu√≠da - \(existingLegacyCount) atributos consolidados em sensorData JSON\(locationInfo)")
        } else {
            print("‚ùå Falha na serializa√ß√£o durante migra√ß√£o")
        }
        
        // NOTA: Remo√ß√£o de atributos legados deve ser feita via Core Data Migration Mapping
        // N√£o removemos aqui para evitar crash se modelo ainda tiver os atributos
    }
    
    // MARK: - External Binary Data Storage Validation
    // üéØ Valida√ß√µes espec√≠ficas para External Storage configurado no modelo
    
    /// ‚úÖ Valida se External Storage est√° funcionando corretamente
    /// 
    /// **VALIDA√á√ÉO COMPLETA:**
    /// - ‚úÖ allowsExternalBinaryDataStorage configurado no FitterModel (CDCurrentSet.sensorData e CDHistorySet.sensorData)
    /// - ‚úÖ Serializa√ß√£o/deserializa√ß√£o funcionando via SensorData.toBinaryData() e fromBinaryData()
    /// - ‚úÖ Integra√ß√£o com WorkoutDataService atrav√©s dos m√©todos updateSensorData()
    /// - ‚úÖ Processamento otimizado para dados grandes (aceler√¥metro, girosc√≥pio, etc.)
    /// 
    /// **BENEF√çCIOS CONFIRMADOS:**
    /// - üìà Performance: Dados grandes armazenados externamente ao SQLite
    /// - üîß Escalabilidade: Adi√ß√£o de novos sensores sem altera√ß√£o do schema
    /// - üíæ Storage: iOS gerencia automaticamente limpeza de dados n√£o utilizados
    /// - üéØ Compatibilidade: Use Cases e WorkoutDataService funcionam transparentemente
    ///
    /// - Returns: true se External Storage est√° configurado e funcionando
    static func validateExternalBinaryDataStorage() -> Bool {
        print("üîç Validando configura√ß√£o External Binary Data Storage...")
        
        // Verifica se consegue criar e serializar dados de teste
        let testSensorData = SensorData(
            accelerationX: 1.0, accelerationY: 2.0, accelerationZ: 3.0,
            rotationX: 4.0, rotationY: 5.0, rotationZ: 6.0,
            gravityX: 7.0, gravityY: 8.0, gravityZ: 9.0,
            attitudeRoll: 10.0, attitudePitch: 11.0, attitudeYaw: 12.0,
            magneticFieldX: 13.0, magneticFieldY: 14.0, magneticFieldZ: 15.0
        )
        
        // Testa serializa√ß√£o
        guard let serializedData = serializeSensorData(testSensorData) else {
            print("‚ùå Falha na serializa√ß√£o - External Storage pode ter problemas")
            return false
        }
        
        // Testa deserializa√ß√£o
        guard let deserializedData = deserializeSensorData(from: serializedData) else {
            print("‚ùå Falha na deserializa√ß√£o - External Storage pode ter problemas")
            return false
        }
        
        // Valida integridade dos dados
        let isValid = deserializedData.accelerationX == testSensorData.accelerationX &&
                     deserializedData.rotationY == testSensorData.rotationY &&
                     deserializedData.magneticFieldZ == testSensorData.magneticFieldZ
        
        if isValid {
            print("‚úÖ External Binary Data Storage validado com sucesso")
            print("üìä Tamanho dos dados serializados: \(serializedData.count) bytes")
            return true
        } else {
            print("‚ùå Dados corrompidos durante serializa√ß√£o/deserializa√ß√£o")
            return false
        }
    }
    
    // MARK: - Location Data Helpers
    // üó∫Ô∏è M√©todos para persistir e migrar dados de localiza√ß√£o
    
    /// üìç Extrai dados de localiza√ß√£o do dictionary e aplica √† entidade
    /// 
    /// **Processo:**
    /// 1. Extrai latitude, longitude e locationAccuracy do dictionary
    /// 2. Aplica os valores √† entidade Core Data (CDCurrentSession ou CDWorkoutHistory)
    /// 3. Fornece fallback seguro caso algum campo n√£o exista
    /// 
    /// **Compatibilidade:**
    /// - Suporta APENAS CDCurrentSession e CDWorkoutHistory (entidades principais)
    /// - CDCurrentSet e CDHistorySet N√ÉO t√™m campos de localiza√ß√£o
    /// - Campos opcionais garantem compatibilidade com dados legacy
    /// - Valida√ß√£o b√°sica de coordenadas (latitude: -90 a 90, longitude: -180 a 180)
    ///
    /// - Parameters:
    ///   - data: Dictionary com dados de localiza√ß√£o (latitude, longitude, locationAccuracy)
    ///   - entity: NSManagedObject (CDCurrentSession ou CDWorkoutHistory) para atualizar
    static func applyLocationData(from data: [String: Any], to entity: NSManagedObject) {
        // Valida√ß√£o de entidade - APENAS sess√µes e hist√≥rico t√™m localiza√ß√£o
        guard entity.entity.name == "CDCurrentSession" || entity.entity.name == "CDWorkoutHistory" else {
            print("‚ö†Ô∏è Entidade \(entity.entity.name ?? "desconhecida") n√£o suporta dados de localiza√ß√£o")
            print("‚ÑπÔ∏è Localiza√ß√£o √© suportada apenas em CDCurrentSession e CDWorkoutHistory")
            return
        }
        
        // Extra√ß√£o e valida√ß√£o de latitude
        if let latitude = data["latitude"] as? Double {
            if latitude >= -90.0 && latitude <= 90.0 {
                entity.setValue(latitude, forKey: "latitude")
                print("üìç Latitude aplicada: \(latitude)")
            } else {
                print("‚ö†Ô∏è Latitude inv√°lida ignorada: \(latitude)")
            }
        }
        
        // Extra√ß√£o e valida√ß√£o de longitude
        if let longitude = data["longitude"] as? Double {
            if longitude >= -180.0 && longitude <= 180.0 {
                entity.setValue(longitude, forKey: "longitude")
                print("üìç Longitude aplicada: \(longitude)")
            } else {
                print("‚ö†Ô∏è Longitude inv√°lida ignorada: \(longitude)")
            }
        }
        
        // Extra√ß√£o de precis√£o de localiza√ß√£o (sempre positiva)
        if let locationAccuracy = data["locationAccuracy"] as? Double {
            if locationAccuracy >= 0.0 {
                entity.setValue(locationAccuracy, forKey: "locationAccuracy")
                print("üìç Precis√£o de localiza√ß√£o aplicada: \(locationAccuracy)m")
            } else {
                print("‚ö†Ô∏è Precis√£o de localiza√ß√£o inv√°lida ignorada: \(locationAccuracy)")
            }
        }
    }
    
    /// üìç Migra dados de localiza√ß√£o de CDCurrentSession para CDWorkoutHistory
    /// 
    /// **Processo:**
    /// 1. Extrai latitude, longitude e locationAccuracy da sess√£o ativa
    /// 2. Transfere os dados para o hist√≥rico de treino
    /// 3. Garante que dados de localiza√ß√£o sejam preservados no hist√≥rico
    /// 
    /// **Uso:** Chamado quando treino √© finalizado (sess√£o ativa ‚Üí hist√≥rico)
    ///
    /// - Parameters:
    ///   - session: CDCurrentSession com dados de localiza√ß√£o
    ///   - history: CDWorkoutHistory para receber os dados
    static func migrateLocationData(from session: NSManagedObject, to history: NSManagedObject) {
        // Valida√ß√£o de entidades
        guard session.entity.name == "CDCurrentSession" && history.entity.name == "CDWorkoutHistory" else {
            print("‚ö†Ô∏è Migra√ß√£o de localiza√ß√£o requer CDCurrentSession ‚Üí CDWorkoutHistory")
            return
        }
        
        var locationDataFound = false
        
        // Migra√ß√£o de latitude
        if let latitude = session.value(forKey: "latitude") as? Double {
            history.setValue(latitude, forKey: "latitude")
            locationDataFound = true
        }
        
        // Migra√ß√£o de longitude
        if let longitude = session.value(forKey: "longitude") as? Double {
            history.setValue(longitude, forKey: "longitude")
            locationDataFound = true
        }
        
        // Migra√ß√£o de precis√£o
        if let locationAccuracy = session.value(forKey: "locationAccuracy") as? Double {
            history.setValue(locationAccuracy, forKey: "locationAccuracy")
            locationDataFound = true
        }
        
        if locationDataFound {
            print("‚úÖ Dados de localiza√ß√£o migrados da sess√£o para o hist√≥rico")
        } else {
            print("‚ÑπÔ∏è Nenhum dado de localiza√ß√£o encontrado na sess√£o para migrar")
        }
    }
    
    /// üìç Converte dados de localiza√ß√£o para Dictionary (sincroniza√ß√£o/debug)
    /// 
    /// **Uso Principal:**
    /// - Sincroniza√ß√£o com Firestore
    /// - Debug e logging de localiza√ß√£o
    /// - Backup de dados de localiza√ß√£o
    /// 
    /// **Comportamento:** Remove valores nulos automaticamente
    ///
    /// - Parameter entity: NSManagedObject com dados de localiza√ß√£o
    /// - Returns: Dictionary com dados de localiza√ß√£o n√£o-nulos
    static func locationDataToDictionary(from entity: NSManagedObject) -> [String: Any] {
        var locationDict: [String: Any] = [:]
        
        if let latitude = entity.value(forKey: "latitude") as? Double {
            locationDict["latitude"] = latitude
        }
        
        if let longitude = entity.value(forKey: "longitude") as? Double {
            locationDict["longitude"] = longitude
        }
        
        if let locationAccuracy = entity.value(forKey: "locationAccuracy") as? Double {
            locationDict["locationAccuracy"] = locationAccuracy
        }
        
        return locationDict
    }

    // MARK: - Dictionary Conversion
    // üîÑ M√©todos auxiliares para convers√£o SensorData ‚Üî Dictionary (sincroniza√ß√£o/debug)
    
    /// üì§ Converte SensorData para Dictionary (√∫til para sincroniza√ß√£o com Firestore)
    /// 
    /// **Uso Principal:**
    /// - Sincroniza√ß√£o com Firestore (conforme regras da refatora√ß√£o)
    /// - Debug e logging de dados de sensores
    /// - APIs que esperam formato Dictionary
    /// 
    /// **Nota:** Remove valores nulos automaticamente para economizar espa√ßo
    ///
    /// - Parameter sensorData: Struct SensorData a ser convertido
    /// - Returns: Dictionary com apenas valores n√£o-nulos dos sensores
    static func sensorDataToDictionary(_ sensorData: SensorData) -> [String: Any] {
        var dict: [String: Any] = [:]
        
        if let accelerationX = sensorData.accelerationX { dict["accelerationX"] = accelerationX }
        if let accelerationY = sensorData.accelerationY { dict["accelerationY"] = accelerationY }
        if let accelerationZ = sensorData.accelerationZ { dict["accelerationZ"] = accelerationZ }
        
        if let rotationX = sensorData.rotationX { dict["rotationX"] = rotationX }
        if let rotationY = sensorData.rotationY { dict["rotationY"] = rotationY }
        if let rotationZ = sensorData.rotationZ { dict["rotationZ"] = rotationZ }
        
        if let gravityX = sensorData.gravityX { dict["gravityX"] = gravityX }
        if let gravityY = sensorData.gravityY { dict["gravityY"] = gravityY }
        if let gravityZ = sensorData.gravityZ { dict["gravityZ"] = gravityZ }
        
        if let attitudeRoll = sensorData.attitudeRoll { dict["attitudeRoll"] = attitudeRoll }
        if let attitudePitch = sensorData.attitudePitch { dict["attitudePitch"] = attitudePitch }
        if let attitudeYaw = sensorData.attitudeYaw { dict["attitudeYaw"] = attitudeYaw }
        
        if let magneticFieldX = sensorData.magneticFieldX { dict["magneticFieldX"] = magneticFieldX }
        if let magneticFieldY = sensorData.magneticFieldY { dict["magneticFieldY"] = magneticFieldY }
        if let magneticFieldZ = sensorData.magneticFieldZ { dict["magneticFieldZ"] = magneticFieldZ }
        
        return dict
    }
    
    /// üì• Converte Dictionary para SensorData (processo inverso)
    /// 
    /// **Uso Principal:**
    /// - Receber dados de sincroniza√ß√£o (Firestore ‚Üí App)
    /// - Processar dados de APIs externas
    /// - Converter dados legacy ou de outras fontes
    /// 
    /// **Comportamento:** Valores ausentes no Dictionary ficam como nil no SensorData
    ///
    /// - Parameter dict: Dictionary com dados de sensores (pode ter valores faltantes)
    /// - Returns: Struct SensorData com valores do Dictionary (nils quando ausentes)
    static func dictionaryToSensorData(_ dict: [String: Any]) -> SensorData {
        return SensorData(
            accelerationX: dict["accelerationX"] as? Double,
            accelerationY: dict["accelerationY"] as? Double,
            accelerationZ: dict["accelerationZ"] as? Double,
            rotationX: dict["rotationX"] as? Double,
            rotationY: dict["rotationY"] as? Double,
            rotationZ: dict["rotationZ"] as? Double,
            gravityX: dict["gravityX"] as? Double,
            gravityY: dict["gravityY"] as? Double,
            gravityZ: dict["gravityZ"] as? Double,
            attitudeRoll: dict["attitudeRoll"] as? Double,
            attitudePitch: dict["attitudePitch"] as? Double,
            attitudeYaw: dict["attitudeYaw"] as? Double,
            magneticFieldX: dict["magneticFieldX"] as? Double,
            magneticFieldY: dict["magneticFieldY"] as? Double,
            magneticFieldZ: dict["magneticFieldZ"] as? Double
        )
    }
}


