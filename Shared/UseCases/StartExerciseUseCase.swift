//
//  StartExerciseUseCase.swift
//  Fitter V2
//
//  üìã RESPONSABILIDADE: Iniciar exerc√≠cio individual dentro de uma sess√£o ativa
//  
//  üéØ OPERA√á√ïES PRINCIPAIS:
//  ‚Ä¢ Finalizar exerc√≠cio atual (se existir)
//  ‚Ä¢ Navegar para pr√≥ximo exerc√≠cio no plano
//  ‚Ä¢ Criar CDCurrentExercise para template espec√≠fico
//  ‚Ä¢ Atualizar currentExerciseIndex na sess√£o
//  ‚Ä¢ Sincronizar dados via SyncWorkoutUseCase (opcional)
//  ‚Ä¢ Preparar integra√ß√£o com HealthKit (item 54)
//  ‚Ä¢ Notificar Apple Watch sobre novo exerc√≠cio
//  
//  üèóÔ∏è ARQUITETURA:
//  ‚Ä¢ Protocol + Implementation para testabilidade
//  ‚Ä¢ Dependency Injection: WorkoutDataService + SyncWorkoutUseCase
//  ‚Ä¢ Error handling espec√≠fico com StartExerciseError enum
//  ‚Ä¢ Input validation com StartExerciseInput struct
//  ‚Ä¢ Async/await nativo para performance
//  
//  ‚ö° INTEGRA√á√ÉO:
//  ‚Ä¢ WorkoutDataService: Opera√ß√µes CRUD de exerc√≠cios
//  ‚Ä¢ SyncWorkoutUseCase: Sincroniza√ß√£o autom√°tica (opcional)
//  ‚Ä¢ ConnectivityManager: Notifica√ß√£o Apple Watch
//  ‚Ä¢ HealthKitManager: Sess√£o HealthKit √© iniciada/finalizada apenas em Start/EndWorkoutUseCase.
// Aqui, apenas leitura de dados em tempo real se necess√°rio (ex: feedback, an√°lise).
//  
//  üîÑ LIFECYCLE:
//  1. Valida√ß√£o de entrada (sess√£o ativa, template v√°lido)
//  2. Finaliza√ß√£o do exerc√≠cio atual (se existir)
//  3. Navega√ß√£o para pr√≥ximo exerc√≠cio do plano
//  4. Cria√ß√£o de CDCurrentExercise
//  5. Atualiza√ß√£o do √≠ndice na sess√£o
//  6. Sincroniza√ß√£o autom√°tica (opcional)
//  7. Notifica√ß√£o para Apple Watch
//  8. Prepara√ß√£o de workout segment HealthKit (futuro)
//
//  Created by Daniel Lobo on 13/05/25.
//

import Foundation
import CoreData

// MARK: - StartExerciseInput

/// Input para iniciar um exerc√≠cio individual
/// Consolida todos os par√¢metros necess√°rios com valida√ß√µes
struct StartExerciseInput {
    let session: CDCurrentSession
    let template: CDExerciseTemplate  // Template espec√≠fico OU
    let exerciseIndex: Int32?         // √çndice no plano (mutuamente exclusivos)
    let user: CDAppUser  // ‚úÖ LOGIN OBRIGAT√ìRIO - BaseViewModel.currentUser nunca nil
    let startTime: Date
    let autoStartFirstSet: Bool
    let shouldSync: Bool
    let enableHealthKit: Bool
    
    /// Inicializador com template espec√≠fico
    init(
        session: CDCurrentSession,
        template: CDExerciseTemplate,
        user: CDAppUser,
        startTime: Date = Date(),
        autoStartFirstSet: Bool = false,
        shouldSync: Bool = true,
        enableHealthKit: Bool = true
    ) {
        self.session = session
        self.template = template
        self.exerciseIndex = nil
        self.user = user
        self.startTime = startTime
        self.autoStartFirstSet = autoStartFirstSet
        self.shouldSync = shouldSync
        self.enableHealthKit = enableHealthKit
    }
    
    /// Inicializador com navega√ß√£o por √≠ndice
    init(
        session: CDCurrentSession,
        exerciseIndex: Int32,
        user: CDAppUser,
        startTime: Date = Date(),
        autoStartFirstSet: Bool = false,
        shouldSync: Bool = true,
        enableHealthKit: Bool = true
    ) throws {
        self.session = session
        self.exerciseIndex = exerciseIndex
        self.user = user
        self.startTime = startTime
        self.autoStartFirstSet = autoStartFirstSet
        self.shouldSync = shouldSync
        self.enableHealthKit = enableHealthKit
        
        // Buscar template pelo √≠ndice
        guard let plan = session.plan,
              exerciseIndex >= 0,
              exerciseIndex < plan.exercisesArray.count else {
            throw StartExerciseError.exerciseIndexOutOfRange
        }
        
        guard let template = plan.exercisesArray[Int(exerciseIndex)].template else {
            throw StartExerciseError.templateNotFound
        }
        
        self.template = template
    }
    
    /// Valida√ß√£o b√°sica de entrada
    var isValid: Bool {
        return session.isActive && 
               !session.safeId.uuidString.isEmpty &&
               !template.safeName.isEmpty &&
               session.user == user
    }
}

// MARK: - StartExerciseError

/// Erros espec√≠ficos para in√≠cio de exerc√≠cio
enum StartExerciseError: LocalizedError {
    case sessionNotActive
    case sessionNotFound
    case templateNotFound
    case exerciseIndexOutOfRange
    case planNotFound
    case exerciseAlreadyActive
    case workoutDataServiceError(Error)
    case syncError(Error)
    case healthKitError(Error)
    case watchConnectivityError
    case invalidInput
    case unknownError(Error)
    
    var errorDescription: String? {
        switch self {
        case .sessionNotActive:
            return "Sess√£o de treino n√£o est√° ativa."
        case .sessionNotFound:
            return "Sess√£o de treino n√£o encontrada."
        case .templateNotFound:
            return "Template de exerc√≠cio n√£o encontrado."
        case .exerciseIndexOutOfRange:
            return "√çndice de exerc√≠cio fora do intervalo do plano."
        case .planNotFound:
            return "Plano de treino n√£o encontrado na sess√£o."
        case .exerciseAlreadyActive:
            return "J√° existe um exerc√≠cio ativo. Finalize o atual primeiro."
        case .workoutDataServiceError(let error):
            return "Erro ao salvar dados do exerc√≠cio: \(error.localizedDescription)"
        case .syncError(let error):
            return "Erro na sincroniza√ß√£o: \(error.localizedDescription)"
        case .healthKitError(let error):
            return "Erro no HealthKit: \(error.localizedDescription)"
        case .watchConnectivityError:
            return "Erro na comunica√ß√£o com Apple Watch."
        case .invalidInput:
            return "Dados de entrada inv√°lidos para iniciar exerc√≠cio."
        case .unknownError(let error):
            return "Erro inesperado: \(error.localizedDescription)"
        }
    }
}

// MARK: - StartExerciseResult

/// Resultado do in√≠cio de exerc√≠cio
struct StartExerciseResult {
    let exercise: CDCurrentExercise
    let previousExercise: CDCurrentExercise?
    let exerciseIndex: Int32
    let isFirstSet: CDCurrentSet?
    let syncStatus: SyncStatus
    let healthKitStatus: HealthKitStatus
    let watchNotified: Bool
    
    /// Status de sincroniza√ß√£o
    enum SyncStatus {
        case synced
        case pending
        case failed(Error)
        case skipped
        case disabled
        
        var isSuccessful: Bool {
            if case .failed = self { return false }
            return true
        }
    }
    
    /// Status do HealthKit
    enum HealthKitStatus {
        case segmentStarted
        case failed(Error)
        case skipped
        case disabled
        
        var isSuccessful: Bool {
            if case .failed = self { return false }
            return true
        }
    }
}

// MARK: - StartExerciseUseCaseProtocol

/// Protocolo para in√≠cio de exerc√≠cio (testabilidade)
protocol StartExerciseUseCaseProtocol {
    func execute(_ input: StartExerciseInput) async throws -> StartExerciseResult
    func executeNextExercise(in session: CDCurrentSession, user: CDAppUser) async throws -> StartExerciseResult?
    func executeSpecificExercise(template: CDExerciseTemplate, in session: CDCurrentSession, user: CDAppUser) async throws -> StartExerciseResult
    func canStartExercise(in session: CDCurrentSession) -> Bool
    func getNextExerciseTemplate(in session: CDCurrentSession) -> CDExerciseTemplate?
}

// MARK: - StartExerciseUseCase

/// Use Case para iniciar exerc√≠cio individual dentro de uma sess√£o ativa
/// Substitui o WorkoutDataService.nextExercise() que estava quebrado
final class StartExerciseUseCase: StartExerciseUseCaseProtocol {
    
    // MARK: - Dependencies
    
    private let workoutDataService: WorkoutDataServiceProtocol
    private let syncWorkoutUseCase: SyncWorkoutUseCaseProtocol?
    // TODO: Adicionar HealthKitManager quando item 65 for implementado (iOSApp.swift)
    // private let healthKitManager: HealthKitManagerProtocol
    
    // MARK: - Initialization
    
    init(
        workoutDataService: WorkoutDataServiceProtocol,
        syncWorkoutUseCase: SyncWorkoutUseCaseProtocol? = nil
    ) {
        self.workoutDataService = workoutDataService
        self.syncWorkoutUseCase = syncWorkoutUseCase
    }
    
    // MARK: - Public Methods
    
    /// Executa in√≠cio de exerc√≠cio com valida√ß√µes robustas
    func execute(_ input: StartExerciseInput) async throws -> StartExerciseResult {
        print("üèÉ‚Äç‚ôÇÔ∏è [START EXERCISE] Iniciando exerc√≠cio: \(input.template.safeName)")
        
        // 1. Valida√ß√£o de entrada
        try await validateInput(input)
        
        // 2. Verificar se pode iniciar exerc√≠cio
        guard canStartExercise(in: input.session) else {
            throw StartExerciseError.exerciseAlreadyActive
        }
        
        // 3. Finalizar exerc√≠cio atual (se existir)
        let previousExercise = try await finalizePreviousExercise(input.session)
        
        // 4. Criar novo exerc√≠cio
        print("üìù [START EXERCISE] Criando exerc√≠cio para usu√°rio: \(input.user.safeName)")
        let exercise: CDCurrentExercise
        do {
            exercise = try await workoutDataService.createCurrentExercise(
                for: input.template,
                in: input.session,
                startTime: input.startTime
            )
        } catch {
            throw StartExerciseError.workoutDataServiceError(error)
        }
        
        // 5. Atualizar √≠ndice da sess√£o
        let exerciseIndex = try await updateSessionIndex(input.session, for: input.template)
        
        // 6. Criar primeira s√©rie (se solicitado)
        var firstSet: CDCurrentSet? = nil
        if input.autoStartFirstSet {
            firstSet = try await createFirstSet(for: exercise)
        }
        
        // 7. Sincroniza√ß√£o autom√°tica (opcional)
        let syncStatus = await performSync(exercise: exercise, shouldSync: input.shouldSync)
        
        // 8. Integra√ß√£o com HealthKit (futuro)
        let healthKitStatus = await startHealthKitSegment(input: input, exercise: exercise)
        
        // 9. Notificar Apple Watch
        let watchNotified = await notifyAppleWatch(exercise: exercise, session: input.session)
        
        let result = StartExerciseResult(
            exercise: exercise,
            previousExercise: previousExercise,
            exerciseIndex: exerciseIndex,
            isFirstSet: firstSet,
            syncStatus: syncStatus,
            healthKitStatus: healthKitStatus,
            watchNotified: watchNotified
        )
        
        print("‚úÖ [START EXERCISE] Exerc√≠cio iniciado com sucesso")
        print("üìä [START EXERCISE] √çndice: \(exerciseIndex), Health: \(healthKitStatus.isSuccessful), Watch: \(watchNotified)")
        
        return result
    }
    
    /// M√©todo de conveni√™ncia para pr√≥ximo exerc√≠cio na sequ√™ncia
    func executeNextExercise(in session: CDCurrentSession, user: CDAppUser) async throws -> StartExerciseResult? {
        guard let nextTemplate = getNextExerciseTemplate(in: session) else {
            print("‚ÑπÔ∏è [START EXERCISE] N√£o h√° pr√≥ximo exerc√≠cio no plano")
            return nil
        }
        
        let input = StartExerciseInput(
            session: session,
            template: nextTemplate,
            user: user
        )
        
        return try await execute(input)
    }
    
    /// M√©todo de conveni√™ncia para exerc√≠cio espec√≠fico
    func executeSpecificExercise(template: CDExerciseTemplate, in session: CDCurrentSession, user: CDAppUser) async throws -> StartExerciseResult {
        let input = StartExerciseInput(
            session: session,
            template: template,
            user: user
        )
        
        return try await execute(input)
    }
    
    /// Verifica se pode iniciar exerc√≠cio (sem exerc√≠cio ativo conflitante)
    func canStartExercise(in session: CDCurrentSession) -> Bool {
        guard session.isActive else { return false }
        
        // Permite se n√£o h√° exerc√≠cio atual OU se o atual j√° foi finalizado
        guard let currentExercise = session.currentExercise else { return true }
        return !currentExercise.isActive || currentExercise.endTime != nil
    }
    
    /// Obt√©m template do pr√≥ximo exerc√≠cio na sequ√™ncia do plano
    func getNextExerciseTemplate(in session: CDCurrentSession) -> CDExerciseTemplate? {
        guard let plan = session.plan else { return nil }
        
        let exercises = plan.exercisesArray
        let nextIndex = Int(session.currentExerciseIndex + 1)
        
        guard nextIndex < exercises.count else { return nil }
        
        return exercises[nextIndex].template
    }
    
    // MARK: - Private Methods
    
    /// Valida√ß√£o robusta de entrada
    private func validateInput(_ input: StartExerciseInput) async throws {
        guard input.isValid else {
            throw StartExerciseError.invalidInput
        }
        
        guard input.session.isActive else {
            throw StartExerciseError.sessionNotActive
        }
        
        guard input.session.plan != nil else {
            throw StartExerciseError.planNotFound
        }
    }
    
    /// Finaliza exerc√≠cio anterior se existir e estiver ativo
    private func finalizePreviousExercise(_ session: CDCurrentSession) async throws -> CDCurrentExercise? {
        guard let currentExercise = session.currentExercise,
              currentExercise.isActive else {
            return nil
        }
        
        print("üèÅ [START EXERCISE] Finalizando exerc√≠cio anterior: \(currentExercise.template?.safeName ?? "Unknown")")
        
        do {
            try await workoutDataService.updateCurrentExercise(currentExercise, endTime: Date())
            return currentExercise
        } catch {
            print("‚ö†Ô∏è [START EXERCISE] Erro ao finalizar exerc√≠cio anterior: \(error)")
            // N√£o falha o processo por causa do exerc√≠cio anterior
            return currentExercise
        }
    }
    
    /// Atualiza √≠ndice da sess√£o baseado no template
    private func updateSessionIndex(_ session: CDCurrentSession, for template: CDExerciseTemplate) async throws -> Int32 {
        guard let plan = session.plan else {
            throw StartExerciseError.planNotFound
        }
        
        let exercises = plan.exercisesArray
        
        // Buscar √≠ndice do template no plano
        for (index, planExercise) in exercises.enumerated() {
            if planExercise.template?.safeId == template.safeId {
                session.currentExerciseIndex = Int32(index)
                
                do {
                    try await workoutDataService.coreDataService.save()
                    print("üìç [START EXERCISE] √çndice atualizado para: \(index)")
                    return Int32(index)
                } catch {
                    throw StartExerciseError.workoutDataServiceError(error)
                }
            }
        }
        
        // Se n√£o encontrou no plano, mant√©m √≠ndice atual + 1
        session.currentExerciseIndex += 1
        
        do {
            try await workoutDataService.coreDataService.save()
            print("üìç [START EXERCISE] √çndice incrementado para: \(session.currentExerciseIndex)")
            return session.currentExerciseIndex
        } catch {
            throw StartExerciseError.workoutDataServiceError(error)
        }
    }
    
    /// Cria primeira s√©rie automaticamente (prepara√ß√£o para item 28)
    private func createFirstSet(for exercise: CDCurrentExercise) async throws -> CDCurrentSet? {
        print("üìä [START EXERCISE] Prepara√ß√£o para primeira s√©rie ser√° implementada no item 28")
        // TODO: Implementar quando StartSetUseCase estiver dispon√≠vel (item 28)
        // guard let startSetUseCase = self.startSetUseCase else { return nil }
        // 
        // let input = StartSetInput(
        //     exercise: exercise,
        //     targetReps: 12, // Valor padr√£o
        //     weight: 0.0,    // Usu√°rio define
        //     order: 0
        // )
        // 
        // do {
        //     let result = try await startSetUseCase.execute(input)
        //     return result.set
        // } catch {
        //     print("‚ö†Ô∏è [START EXERCISE] Erro ao criar primeira s√©rie: \(error)")
        //     return nil
        // }
        
        return nil // Tempor√°rio at√© item 28
    }
    
    /// Sincroniza√ß√£o com tratamento de erro
    private func performSync(exercise: CDCurrentExercise, shouldSync: Bool) async -> StartExerciseResult.SyncStatus {
        guard shouldSync, let syncUseCase = syncWorkoutUseCase else {
            print("‚è≠Ô∏è [START EXERCISE] Sincroniza√ß√£o desabilitada")
            return .disabled
        }
        
        do {
            try await syncUseCase.execute(exercise)
            print("‚òÅÔ∏è [START EXERCISE] Exerc√≠cio sincronizado")
            return .synced
        } catch {
            print("‚ö†Ô∏è [START EXERCISE] Falha na sincroniza√ß√£o: \(error)")
            return .failed(error)
        }
    }
    
    /// Integra√ß√£o com HealthKit (item 45 - CONCLU√çDO)
    private func startHealthKitSegment(input: StartExerciseInput, exercise: CDCurrentExercise) async -> StartExerciseResult.HealthKitStatus {
        guard input.enableHealthKit else {
            print("‚ÑπÔ∏è [START EXERCISE] HealthKit desabilitado pelo usu√°rio")
            return .skipped
        }
        
        print("üè• [START EXERCISE] HealthKit ser√° integrado no item 65 (iOSApp.swift)")
        // TODO: Implementar quando HealthKitManager for injetado no item 65
        // guard let healthKitManager = self.healthKitManager else { return .disabled }
        // 
        // do {
        //     // HealthKit n√£o tem segments, apenas workout sessions
        //     // A integra√ß√£o ser√° feita via workout session ativa
        //     return .segmentStarted
        // } catch {
        //     print("‚ùå [START EXERCISE] HealthKit error: \(error)")
        //     return .failed(error)
        // }
        
        return .disabled // Tempor√°rio at√© item 65
    }
    
    /// Notifica√ß√£o para Apple Watch
    private func notifyAppleWatch(exercise: CDCurrentExercise, session: CDCurrentSession) async -> Bool {
        #if os(iOS)
        do {
            let connectivityManager = ConnectivityManager.shared
            
            let exerciseContext: [String: Any] = [
                "type": "exerciseStarted",
                "sessionId": session.safeId.uuidString,
                "exerciseId": exercise.safeId.uuidString,
                "exerciseName": exercise.template?.safeName ?? "",
                "muscleGroup": exercise.template?.muscleGroup ?? "",
                "equipment": exercise.template?.equipment ?? "",
                "exerciseIndex": session.currentExerciseIndex,
                "startTime": exercise.safeStartTime.timeIntervalSince1970
            ]
            
            await connectivityManager.sendMessage(exerciseContext, replyHandler: nil)
            print("üì±‚û°Ô∏è‚åö Exerc√≠cio notificado ao Watch")
            return true
            
        } catch {
            print("‚ùå [START EXERCISE] Erro ao notificar Watch: \(error)")
            return false
        }
        #else
        print("‚ÑπÔ∏è [START EXERCISE] Notifica√ß√£o Watch apenas dispon√≠vel no iOS")
        return false
        #endif
    }
}

// MARK: - Convenience Extensions

extension StartExerciseUseCase {
    
    /// Inicia exerc√≠cio com configura√ß√µes padr√£o
    func startDefaultExercise(template: CDExerciseTemplate, in session: CDCurrentSession, user: CDAppUser) async throws -> StartExerciseResult {
        return try await executeSpecificExercise(template: template, in: session, user: user)
    }
    
    /// Inicia exerc√≠cio sem sincroniza√ß√£o
    func startExerciseOffline(template: CDExerciseTemplate, in session: CDCurrentSession, user: CDAppUser) async throws -> StartExerciseResult {
        let input = StartExerciseInput(
            session: session,
            template: template,
            user: user,
            shouldSync: false
        )
        return try await execute(input)
    }
    
    /// Inicia exerc√≠cio sem HealthKit
    func startExerciseWithoutHealthKit(template: CDExerciseTemplate, in session: CDCurrentSession, user: CDAppUser) async throws -> StartExerciseResult {
        let input = StartExerciseInput(
            session: session,
            template: template,
            user: user,
            enableHealthKit: false
        )
        return try await execute(input)
    }
}

// MARK: - Navigation Helper

extension StartExerciseUseCase {
    
    /// Verifica se h√° pr√≥ximo exerc√≠cio no plano
    func hasNextExercise(in session: CDCurrentSession) -> Bool {
        return getNextExerciseTemplate(in: session) != nil
    }
    
    /// Conta exerc√≠cios restantes no plano
    func remainingExercisesCount(in session: CDCurrentSession) -> Int {
        guard let plan = session.plan else { return 0 }
        
        let totalExercises = plan.exercisesArray.count
        let currentIndex = Int(session.currentExerciseIndex)
        
        return max(0, totalExercises - currentIndex - 1)
    }
    
    /// Obt√©m lista de exerc√≠cios restantes
    func getRemainingExercises(in session: CDCurrentSession) -> [CDExerciseTemplate] {
        guard let plan = session.plan else { return [] }
        
        let exercises = plan.exercisesArray
        let currentIndex = Int(session.currentExerciseIndex + 1)
        
        guard currentIndex < exercises.count else { return [] }
        
        return Array(exercises[currentIndex...]).compactMap { $0.template }
    }
} 