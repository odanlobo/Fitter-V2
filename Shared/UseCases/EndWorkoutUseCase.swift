//
//  EndWorkoutUseCase.swift
//  Fitter V2
//
//  üìã RESPONSABILIDADE: Finalizar sess√£o de treino + finalizar MotionManager no Watch + salvar hist√≥rico completo
//  
//  üéØ OPERA√á√ïES PRINCIPAIS:
//  ‚Ä¢ Finalizar CDCurrentSession com endTime
//  ‚Ä¢ Finalizar MotionManager no Apple Watch via PhoneSessionManager
//  ‚Ä¢ Migrar dados completos para CDWorkoutHistory
//  ‚Ä¢ Preservar exerc√≠cios e s√©ries com sensorData
//  ‚Ä¢ Calcular estat√≠sticas de performance
//  ‚Ä¢ Sincronizar hist√≥rico via SyncWorkoutUseCase
//  ‚Ä¢ Limpar entidades "current" ap√≥s migra√ß√£o
//  ‚Ä¢ Preparar integra√ß√£o com HealthKit (item 54)
//  
//  üèóÔ∏è ARQUITETURA:
//  ‚Ä¢ Protocol + Implementation para testabilidade
//  ‚Ä¢ Dependency Injection: WorkoutDataService + SyncWorkoutUseCase
//  ‚Ä¢ Error handling espec√≠fico com EndWorkoutError enum
//  ‚Ä¢ Input validation com EndWorkoutInput struct
//  ‚Ä¢ Analytics robustos com EndWorkoutStatistics
//  
//  ‚ö° INTEGRA√á√ÉO:
//  ‚Ä¢ WorkoutDataService: Migra√ß√£o Current ‚Üí History
//  ‚Ä¢ SyncWorkoutUseCase: Sincroniza√ß√£o autom√°tica
//  ‚Ä¢ PhoneSessionManager: Finaliza√ß√£o do MotionManager no Watch
//  ‚Ä¢ HealthKitManager: Finaliza√ß√£o workout session (item 45 - CONCLU√çDO)
//  ‚Ä¢ CoreDataAdapter: Preserva√ß√£o de sensorData JSON
//  
//  üîÑ LIFECYCLE:
//  1. Valida√ß√£o de entrada (sess√£o ativa, usu√°rio)
//  2. Finaliza√ß√£o de CDCurrentSession/Exercise/Set
//  3. Finaliza√ß√£o do MotionManager no Apple Watch
//  4. Migra√ß√£o completa para entidades History
//  5. C√°lculo de estat√≠sticas de performance
//  6. Sincroniza√ß√£o autom√°tica
//  7. Limpeza de dados tempor√°rios
//  8. Finaliza√ß√£o de workout session HealthKit (futuro)
//
//  Created by Daniel Lobo on 13/05/25.
//

import Foundation
import CoreData

// MARK: - EndWorkoutCommand

/// Comando estruturado para finalizar MotionManager no Watch
struct EndWorkoutCommand: WatchCommand {
    let sessionId: String
    let endTime: Date
    let duration: TimeInterval
    let totalExercises: Int
    let totalSets: Int
    
    var commandType: WatchCommandType {
        return .endWorkout
    }
    
    var payload: [String: Any] {
        return [
            "sessionId": sessionId,
            "endTime": endTime.timeIntervalSince1970,
            "duration": duration,
            "totalExercises": totalExercises,
            "totalSets": totalSets
        ]
    }
}

// MARK: - EndWorkoutInput

/// Input para finalizar uma sess√£o de treino
/// Consolida todos os par√¢metros necess√°rios com valida√ß√µes
struct EndWorkoutInput {
    let session: CDCurrentSession
    let user: CDAppUser  // ‚úÖ LOGIN OBRIGAT√ìRIO - BaseViewModel.currentUser nunca nil
    let endTime: Date
    let shouldCalculateStats: Bool
    let shouldSync: Bool
    let saveToHealthKit: Bool
    
    /// Inicializador com valores padr√£o otimizados
    init(
        session: CDCurrentSession,
        user: CDAppUser,
        endTime: Date = Date(),
        shouldCalculateStats: Bool = true,
        shouldSync: Bool = true,
        saveToHealthKit: Bool = true
    ) {
        self.session = session
        self.user = user
        self.endTime = endTime
        self.shouldCalculateStats = shouldCalculateStats
        self.shouldSync = shouldSync
        self.saveToHealthKit = saveToHealthKit
    }
    
    /// Valida√ß√£o b√°sica de entrada
    var isValid: Bool {
        return session.isActive && 
               !session.safeId.uuidString.isEmpty &&
               endTime >= session.safeStartTime
    }
}

// MARK: - EndWorkoutError

/// Erros espec√≠ficos para finaliza√ß√£o de treino
enum EndWorkoutError: Error, LocalizedError {
    case invalidInput
    case sessionNotActive
    case migrationFailed(Error)
    case statsFailed(Error)
    case syncFailed(Error)
    case healthKitFailed(Error)
    case cleanupFailed(Error)
    case sessionNotFound
    case workoutDataServiceError(Error)
    
    var errorDescription: String? {
        switch self {
        case .invalidInput:
            return "Dados de entrada inv√°lidos para finaliza√ß√£o do treino"
        case .sessionNotActive:
            return "Sess√£o n√£o est√° ativa para finaliza√ß√£o"
        case .migrationFailed(let error):
            return "Falha na migra√ß√£o para hist√≥rico: \(error.localizedDescription)"
        case .statsFailed(let error):
            return "Falha no c√°lculo de estat√≠sticas: \(error.localizedDescription)"
        case .syncFailed(let error):
            return "Falha na sincroniza√ß√£o: \(error.localizedDescription)"
        case .healthKitFailed(let error):
            return "Falha no HealthKit: \(error.localizedDescription)"
        case .cleanupFailed(let error):
            return "Falha na limpeza: \(error.localizedDescription)"
        case .sessionNotFound:
            return "Sess√£o n√£o encontrada"
        case .workoutDataServiceError(let error):
            return "Erro no WorkoutDataService: \(error.localizedDescription)"
        }
    }
}

// MARK: - EndWorkoutStatistics

/// Estat√≠sticas calculadas do treino finalizado
struct EndWorkoutStatistics {
    let duration: TimeInterval
    let totalExercises: Int
    let totalSets: Int
    let totalVolume: Double // peso √ó reps total
    let averageRestTime: TimeInterval?
    let totalCalories: Double?
    let averageHeartRate: Int?
    let exercisesCompleted: Int
    let setsCompleted: Int
    let personalRecords: [String] // PRs atingidos
    
    /// Resumo textual das estat√≠sticas
    var summary: String {
        let durationMinutes = Int(duration / 60)
        let durationSeconds = Int(duration.truncatingRemainder(dividingBy: 60))
        
        var summary = "Dura√ß√£o: \(durationMinutes)m \(durationSeconds)s"
        summary += ", Exerc√≠cios: \(exercisesCompleted)/\(totalExercises)"
        summary += ", S√©ries: \(setsCompleted)/\(totalSets)"
        summary += ", Volume: \(String(format: "%.1f", totalVolume))kg"
        
        if let calories = totalCalories {
            summary += ", Calorias: \(Int(calories))"
        }
        
        if !personalRecords.isEmpty {
            summary += ", PRs: \(personalRecords.count)"
        }
        
        return summary
    }
}

// MARK: - EndWorkoutResult

/// Resultado da finaliza√ß√£o do treino
struct EndWorkoutResult {
    let workoutHistory: CDWorkoutHistory
    let statistics: EndWorkoutStatistics
    let syncStatus: SyncStatus
    let healthKitStatus: HealthKitStatus
    let migrationDetails: MigrationDetails
    
    /// Status de sincroniza√ß√£o
    enum SyncStatus {
        case synced
        case failed(Error)
        case skipped
        case disabled
        
        var isSuccessful: Bool {
            if case .failed = self { return false }
            return true
        }
    }
    
    /// Status do HealthKit
    enum HealthKitStatus {
        case saved
        case failed(Error)
        case skipped
        case disabled
        
        var isSuccessful: Bool {
            if case .failed = self { return false }
            return true
        }
    }
    
    /// Detalhes da migra√ß√£o
    struct MigrationDetails {
        let migratedExercises: Int
        let migratedSets: Int
        let preservedSensorData: Int
        let migrationTime: TimeInterval
        
        var summary: String {
            return "\(migratedExercises) exerc√≠cios, \(migratedSets) s√©ries, \(preservedSensorData) sensores em \(String(format: "%.2f", migrationTime))s"
        }
    }
}

// MARK: - EndWorkoutUseCaseProtocol

protocol EndWorkoutUseCaseProtocol {
    func execute(_ input: EndWorkoutInput) async throws -> EndWorkoutResult
    func executeQuickEnd(session: CDCurrentSession, user: CDAppUser) async throws -> EndWorkoutResult
    func canEndWorkout(session: CDCurrentSession) -> Bool
    func calculateSessionStatistics(_ session: CDCurrentSession) async throws -> EndWorkoutStatistics
}

// MARK: - EndWorkoutUseCase

final class EndWorkoutUseCase: EndWorkoutUseCaseProtocol {
    
    // MARK: - Dependencies
    
    private let workoutDataService: WorkoutDataServiceProtocol
    private let syncWorkoutUseCase: SyncWorkoutUseCaseProtocol
    private let locationManager: LocationManagerProtocol
    // TODO: Adicionar HealthKitManager quando item 65 for implementado (iOSApp.swift)
    // private let healthKitManager: HealthKitManagerProtocol
    
    // MARK: - Initialization
    
    init(
        workoutDataService: WorkoutDataServiceProtocol,
        syncWorkoutUseCase: SyncWorkoutUseCaseProtocol,
        locationManager: LocationManagerProtocol
    ) {
        self.workoutDataService = workoutDataService
        self.syncWorkoutUseCase = syncWorkoutUseCase
        self.locationManager = locationManager
    }
    
    // MARK: - Public Methods
    
    /// Executa finaliza√ß√£o completa de treino com migra√ß√£o para hist√≥rico
    func execute(_ input: EndWorkoutInput) async throws -> EndWorkoutResult {
        print("üèÅ [END WORKOUT] Iniciando finaliza√ß√£o da sess√£o: \(input.session.safeId)")
        
        let startTime = Date()
        
        do {
            // 1. Validar entrada
            try await validateInput(input)
            
            // 2. Finalizar entidades "current"
            try await finalizeCurrentEntities(input.session, endTime: input.endTime)
            
            // 3. Finalizar MotionManager no Apple Watch
            let watchFinalized = await finalizeMotionManager(input.session, endTime: input.endTime)
            
            // 4. Migrar para hist√≥rico
            let (workoutHistory, migrationDetails) = try await migrateToHistory(input.session, user: input.user, endTime: input.endTime)
            
            // 4.1. Salvar localiza√ß√£o final no hist√≥rico (opcional)
            await saveLocationToHistory(workoutHistory)
            
            // 5. Calcular estat√≠sticas
            let statistics = input.shouldCalculateStats ? 
                try await calculateDetailedStatistics(input.session, workoutHistory) :
                try await calculateBasicStatistics(input.session)
            
            // 6. Finalizar HealthKit
            let healthKitStatus = await finalizeHealthKitSession(input)
            
            // 7. Sincronizar
            let syncStatus = await performSync(workoutHistory, shouldSync: input.shouldSync)
            
            // 8. Limpeza final
            try await performCleanup(input.session)
            
            let result = EndWorkoutResult(
                workoutHistory: workoutHistory,
                statistics: statistics,
                syncStatus: syncStatus,
                healthKitStatus: healthKitStatus,
                migrationDetails: migrationDetails
            )
            
            let duration = Date().timeIntervalSince(startTime)
            print("üéâ [END WORKOUT] Treino finalizado com sucesso em \(String(format: "%.2f", duration))s")
            print("üìä [END WORKOUT] Estat√≠sticas: \(statistics.summary)")
            print("üìà [END WORKOUT] Migra√ß√£o: \(migrationDetails.summary)")
            
            return result
            
        } catch let error as EndWorkoutError {
            print("‚ùå [END WORKOUT] Erro na finaliza√ß√£o: \(error.localizedDescription)")
            throw error
        } catch {
            print("‚ùå [END WORKOUT] Erro inesperado: \(error)")
            throw EndWorkoutError.workoutDataServiceError(error)
        }
    }
    
    /// M√©todo de conveni√™ncia para finaliza√ß√£o r√°pida
    func executeQuickEnd(session: CDCurrentSession, user: CDAppUser) async throws -> EndWorkoutResult {
        let input = EndWorkoutInput(session: session, user: user)
        return try await execute(input)
    }
    
    /// Verifica se sess√£o pode ser finalizada
    func canEndWorkout(session: CDCurrentSession) -> Bool {
        return session.isActive && 
               !session.safeId.uuidString.isEmpty &&
               session.safeStartTime.timeIntervalSinceNow < 0 // Iniciada no passado
    }
    
    /// Calcula estat√≠sticas da sess√£o (sem migra√ß√£o)
    func calculateSessionStatistics(_ session: CDCurrentSession) async throws -> EndWorkoutStatistics {
        return try await calculateBasicStatistics(session)
    }
    
    // MARK: - Private Methods
    
    /// Valida√ß√£o robusta de entrada
    private func validateInput(_ input: EndWorkoutInput) async throws {
        guard input.isValid else {
            throw EndWorkoutError.invalidInput
        }
        
        guard input.session.isActive else {
            throw EndWorkoutError.sessionNotActive
        }
        
        guard canEndWorkout(session: input.session) else {
            throw EndWorkoutError.sessionNotActive
        }
    }
    
    /// Finaliza todas as entidades "current" com endTime
    private func finalizeCurrentEntities(_ session: CDCurrentSession, endTime: Date) async throws {
        do {
            // 1. Finalizar sess√£o
            try await workoutDataService.updateCurrentSession(session, endTime: endTime)
            print("‚úÖ [END WORKOUT] Sess√£o finalizada")
            
            // 2. Finalizar exerc√≠cio atual se existir
            if let currentExercise = session.currentExercise {
                try await workoutDataService.updateCurrentExercise(currentExercise, endTime: endTime)
                print("‚úÖ [END WORKOUT] Exerc√≠cio atual finalizado")
                
                // 3. Finalizar set atual se existir
                if let currentSet = currentExercise.currentSet {
                    try await workoutDataService.updateCurrentSet(
                        currentSet,
                        actualReps: currentSet.actualReps ?? currentSet.targetReps,
                        restTime: currentSet.restTime,
                        endTime: endTime,
                        sensorData: nil // Preserva dados existentes
                    )
                    print("‚úÖ [END WORKOUT] Set atual finalizado")
                }
            }
            
        } catch {
            throw EndWorkoutError.workoutDataServiceError(error)
        }
    }
    
    /// Migra dados completos para hist√≥rico
    private func migrateToHistory(_ session: CDCurrentSession, user: CDAppUser, endTime: Date) async throws -> (CDWorkoutHistory, EndWorkoutResult.MigrationDetails) {
        let migrationStart = Date()
        
        do {
            // 1. Criar workout history
            let workoutHistory = try await workoutDataService.createWorkoutHistory(
                from: session,
                user: user,
                date: endTime
            )
            print("üìú [END WORKOUT] WorkoutHistory criado")
            
            // 2. Migrar exerc√≠cios e s√©ries
            let (migratedExercises, migratedSets, preservedSensorData) = try await migrateExercisesAndSets(
                from: session,
                to: workoutHistory
            )
            
            let migrationTime = Date().timeIntervalSince(migrationStart)
            let migrationDetails = EndWorkoutResult.MigrationDetails(
                migratedExercises: migratedExercises,
                migratedSets: migratedSets,
                preservedSensorData: preservedSensorData,
                migrationTime: migrationTime
            )
            
            return (workoutHistory, migrationDetails)
            
        } catch {
            throw EndWorkoutError.migrationFailed(error)
        }
    }
    
    /// Migra exerc√≠cios e s√©ries preservando sensorData
    private func migrateExercisesAndSets(from session: CDCurrentSession, to workoutHistory: CDWorkoutHistory) async throws -> (Int, Int, Int) {
        guard let plan = session.plan else {
            return (0, 0, 0)
        }
        
        var migratedExercises = 0
        var migratedSets = 0
        var preservedSensorData = 0
        
        // Buscar todos os current sets da sess√£o
        let allCurrentSets = try await workoutDataService.fetchCurrentSets(for: nil)
        
        // Agrupar sets por exerc√≠cio (baseado no template)
        var exerciseGroups: [String: [CDCurrentSet]] = [:]
        for set in allCurrentSets {
            guard let exerciseName = set.exercise?.template?.safeName else { continue }
            exerciseGroups[exerciseName, default: []].append(set)
        }
        
        // Migrar cada grupo de exerc√≠cios
        for (exerciseName, sets) in exerciseGroups {
            // Criar CDHistoryExercise
            let historyExercise = try await createHistoryExercise(
                name: exerciseName,
                order: Int32(migratedExercises),
                workoutHistory: workoutHistory
            )
            migratedExercises += 1
            
            // Migrar todas as s√©ries do exerc√≠cio
            for (index, set) in sets.enumerated() {
                try await workoutDataService.createHistorySet(
                    from: set,
                    exercise: historyExercise,
                    order: Int32(index)
                )
                migratedSets += 1
                
                // Contar sensorData preservado
                if set.sensorData != nil {
                    preservedSensorData += 1
                }
            }
        }
        
        print("üîÑ [END WORKOUT] Migra√ß√£o conclu√≠da: \(migratedExercises) exerc√≠cios, \(migratedSets) s√©ries")
        return (migratedExercises, migratedSets, preservedSensorData)
    }
    
    /// Cria CDHistoryExercise via WorkoutDataService ‚úÖ
    private func createHistoryExercise(name: String, order: Int32, workoutHistory: CDWorkoutHistory) async throws -> CDHistoryExercise {
        // ‚úÖ CLEAN ARCHITECTURE: Usa WorkoutDataService diretamente
        return try await workoutDataService.createHistoryExercise(
            name: name,
            order: order,
            workoutHistory: workoutHistory
        )
    }
    
    /// Calcula estat√≠sticas b√°sicas da sess√£o
    private func calculateBasicStatistics(_ session: CDCurrentSession) async throws -> EndWorkoutStatistics {
        do {
            let duration = session.duration
            let planExercises = session.plan?.exercisesArray ?? []
            let totalExercises = planExercises.count
            
            // Buscar current sets da sess√£o
            let allCurrentSets = try await workoutDataService.fetchCurrentSets(for: nil)
            let totalSets = allCurrentSets.count
            let setsCompleted = allCurrentSets.filter { $0.endTime != nil }.count
            
            // Calcular volume total (peso √ó reps)
            let totalVolume = allCurrentSets.reduce(0.0) { sum, set in
                let reps = Double(set.actualReps ?? set.targetReps)
                return sum + (set.weight * reps)
            }
            
            // Contar exerc√≠cios √∫nicos
            let uniqueExercises = Set(allCurrentSets.compactMap { $0.exercise?.template?.safeName })
            let exercisesCompleted = uniqueExercises.count
            
            return EndWorkoutStatistics(
                duration: duration,
                totalExercises: totalExercises,
                totalSets: totalSets,
                totalVolume: totalVolume,
                averageRestTime: nil,
                totalCalories: nil,
                averageHeartRate: nil,
                exercisesCompleted: exercisesCompleted,
                setsCompleted: setsCompleted,
                personalRecords: []
            )
            
        } catch {
            throw EndWorkoutError.statsFailed(error)
        }
    }
    
    /// Calcula estat√≠sticas detalhadas com an√°lise de sensor data
    private func calculateDetailedStatistics(_ session: CDCurrentSession, _ workoutHistory: CDWorkoutHistory) async throws -> EndWorkoutStatistics {
        do {
            // Estat√≠sticas b√°sicas
            let basicStats = try await calculateBasicStatistics(session)
            
            // Buscar current sets para an√°lise detalhada
            let allCurrentSets = try await workoutDataService.fetchCurrentSets(for: nil)
            
            // C√°lculos avan√ßados
            let completedSets = allCurrentSets.filter { $0.endTime != nil }
            
            // Tempo de descanso m√©dio
            let restTimes = completedSets.compactMap { $0.restTime }
            let averageRestTime = restTimes.isEmpty ? nil : restTimes.reduce(0, +) / Double(restTimes.count)
            
            // Calorias totais
            let calories = completedSets.compactMap { $0.caloriesBurned }
            let totalCalories = calories.isEmpty ? nil : calories.reduce(0, +)
            
            // Frequ√™ncia card√≠aca m√©dia
            let heartRates = completedSets.compactMap { $0.heartRate }
            let averageHeartRate = heartRates.isEmpty ? nil : Int(Double(heartRates.reduce(0, +)) / Double(heartRates.count))
            
            // TODO: Implementar detec√ß√£o de PRs comparando com hist√≥rico
            let personalRecords: [String] = []
            
            return EndWorkoutStatistics(
                duration: basicStats.duration,
                totalExercises: basicStats.totalExercises,
                totalSets: basicStats.totalSets,
                totalVolume: basicStats.totalVolume,
                averageRestTime: averageRestTime,
                totalCalories: totalCalories,
                averageHeartRate: averageHeartRate,
                exercisesCompleted: basicStats.exercisesCompleted,
                setsCompleted: basicStats.setsCompleted,
                personalRecords: personalRecords
            )
            
        } catch {
            throw EndWorkoutError.statsFailed(error)
        }
    }
    
    /// Finaliza sess√£o HealthKit (item 45 - CONCLU√çDO)
    private func finalizeHealthKitSession(_ input: EndWorkoutInput) async -> EndWorkoutResult.HealthKitStatus {
        guard input.saveToHealthKit else {
            print("‚ÑπÔ∏è [END WORKOUT] HealthKit desabilitado pelo usu√°rio")
            return .skipped
        }
        
        print("üè• [END WORKOUT] HealthKit ser√° integrado no item 65 (iOSApp.swift)")
        // TODO: Implementar quando HealthKitManager for injetado no item 65
        // guard let healthKitManager = self.healthKitManager else { return .disabled }
        // 
        // do {
        //     try await healthKitManager.endWorkoutSession(
        //         session: activeWorkoutSession,
        //         endDate: input.endTime
        //     )
        //     return .saved
        // } catch {
        //     print("‚ùå [END WORKOUT] HealthKit error: \(error)")
        //     return .failed(error)
        // }
        
        return .disabled // Tempor√°rio at√© item 65
    }
    
    /// Sincroniza√ß√£o com tratamento de erro
    private func performSync(_ workoutHistory: CDWorkoutHistory, shouldSync: Bool) async -> EndWorkoutResult.SyncStatus {
        guard shouldSync else {
            print("‚è≠Ô∏è [END WORKOUT] Sincroniza√ß√£o ignorada conforme solicitado")
            return .skipped
        }
        
        do {
            try await syncWorkoutUseCase.execute(workoutHistory)
            print("‚òÅÔ∏è [END WORKOUT] Hist√≥rico sincronizado com sucesso")
            return .synced
        } catch {
            print("‚ö†Ô∏è [END WORKOUT] Falha na sincroniza√ß√£o: \(error)")
            return .failed(error)
        }
    }
    
    /// Finaliza MotionManager no Apple Watch
    private func finalizeMotionManager(_ session: CDCurrentSession, endTime: Date) async -> Bool {
        #if os(iOS)
        print("‚åö [END WORKOUT] Finalizando MotionManager no Apple Watch")
        
        // Integra√ß√£o com PhoneSessionManager para comandos estruturados
        guard let phoneSessionManager = getPhoneSessionManager() else {
            print("‚ö†Ô∏è [END WORKOUT] PhoneSessionManager n√£o dispon√≠vel")
            return false
        }
        
        // Buscar estat√≠sticas b√°sicas para o comando
        let duration = session.duration
        let totalExercises = session.plan?.exercisesArray.count ?? 0
        
        do {
            let allCurrentSets = try await workoutDataService.fetchCurrentSets(for: nil)
            let totalSets = allCurrentSets.count
            
            // Comando estruturado para finalizar MotionManager no Watch
            let endWorkoutCommand = EndWorkoutCommand(
                sessionId: session.safeId.uuidString,
                endTime: endTime,
                duration: duration,
                totalExercises: totalExercises,
                totalSets: totalSets
            )
            
            try await phoneSessionManager.sendCommand(endWorkoutCommand)
            print("‚úÖ [END WORKOUT] MotionManager finalizado no Watch")
            return true
        } catch {
            print("‚ùå [END WORKOUT] Erro ao finalizar MotionManager: \(error)")
            return false
        }
        #else
        print("‚ÑπÔ∏è [END WORKOUT] Watch finalization skipped (watchOS)")
        return false
        #endif
    }
    
    /// Helper para obter PhoneSessionManager
    private func getPhoneSessionManager() -> PhoneSessionManager? {
        #if os(iOS)
        return PhoneSessionManager.shared
        #else
        return nil
        #endif
    }
    
    /// Salva localiza√ß√£o final no hist√≥rico do treino
    private func saveLocationToHistory(_ workoutHistory: CDWorkoutHistory) async {
        print("üìç [END WORKOUT] Salvando localiza√ß√£o no hist√≥rico...")
        
        do {
            // Capturar localiza√ß√£o atual (com timeout de 5s para n√£o atrasar finaliza√ß√£o)
            let location = try await locationManager.getCurrentLocation(timeout: 5.0)
            
            // Atualizar CDWorkoutHistory com localiza√ß√£o
            try await workoutDataService.updateWorkoutHistoryLocation(
                workoutHistory: workoutHistory,
                latitude: location.latitude,
                longitude: location.longitude,
                locationAccuracy: location.accuracy
            )
            
            print("‚úÖ [END WORKOUT] Localiza√ß√£o salva: (\(location.latitude), \(location.longitude)) ¬±\(location.accuracy)m")
            
        } catch LocationManagerError.permissionDenied {
            print("‚ÑπÔ∏è [END WORKOUT] Localiza√ß√£o negada pelo usu√°rio - continuando sem localiza√ß√£o")
        } catch LocationManagerError.timeout {
            print("‚è±Ô∏è [END WORKOUT] Timeout na captura de localiza√ß√£o - continuando sem localiza√ß√£o")
        } catch {
            print("‚ö†Ô∏è [END WORKOUT] Erro ao capturar localiza√ß√£o (n√£o cr√≠tico): \(error)")
        }
    }
    
    /// Limpeza final das entidades tempor√°rias
    private func performCleanup(_ session: CDCurrentSession) async throws {
        do {
            // Opcionalmente excluir current sets
            // try await workoutDataService.deleteAllCurrentSets()
            
            // Opcionalmente excluir current session
            // try await workoutDataService.deleteCurrentSession(session)
            
            print("üßπ [END WORKOUT] Limpeza conclu√≠da")
            
        } catch {
            print("‚ö†Ô∏è [END WORKOUT] Erro na limpeza (n√£o cr√≠tico): \(error)")
            // N√£o falha o processo por causa da limpeza
        }
    }
}

// MARK: - Convenience Extensions

extension EndWorkoutUseCase {
    
    /// Finaliza treino com configura√ß√µes padr√£o
    func endDefaultWorkout(session: CDCurrentSession, user: CDAppUser) async throws -> EndWorkoutResult {
        return try await executeQuickEnd(session: session, user: user)
    }
    
    /// Finaliza treino sem HealthKit
    func endWorkoutWithoutHealthKit(session: CDCurrentSession, user: CDAppUser) async throws -> EndWorkoutResult {
        let input = EndWorkoutInput(
            session: session,
            user: user,
            saveToHealthKit: false
        )
        return try await execute(input)
    }
    
    /// Finaliza treino sem sincroniza√ß√£o
    func endWorkoutOffline(session: CDCurrentSession, user: CDAppUser) async throws -> EndWorkoutResult {
        let input = EndWorkoutInput(
            session: session,
            user: user,
            shouldSync: false
        )
        return try await execute(input)
    }
} 